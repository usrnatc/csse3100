method ComputeFusc(N: int) returns (b: int)
    requires N >= 0
    ensures b == fusc(N)
{
    b := 0;
    var n, a := N, 1;
    while (n != 0)
        invariant fusc(N) == a * fusc(n) + b * fusc(n + 1)
    {
        if (n % 2 == 0) {
            a := a + b;
            {fusc(N) == a * fusc(n / 2) + b * fusc((n / 2) + 1) && n == 0}
            {fusc(N) == a * fusc(n / 2) + b * fusc((n / 2) + 1) && n / 2 == 0}
            n := n / 2;
            {fusc(N) == a * fusc(n) + b * fusc(n + 1) && n == 0}
        } else {
            {fusc(N) == a * fusc(n) + b * fusc(((n - 1) / 2) + 1) && n == 1}
            {fusc(N) == a * (fusc(2 * ((n - 1) / 2) + 1) + b * fusc(((n - 1) / 2) + 1) && n == 1}
            {fusc(N) == a * (fusc((n - 1) / 2) + fusc(((n - 1) / 2) + 1)) + b * fusc(((n - 1) / 2) + 1) && n == 1}
            {fusc(N) == a * fusc((n - 1) / 2) + a * fusc(((n - 1) / 2) + 1) + b * fusc(((n - 1) / 2) + 1) && n == 1}
            {fusc(N) == a * fusc((n - 1) / 2) + (b + a) * fusc(((n - 1) / 2) + 1) && n == 1}
            b := b + a;
            {fusc(N) == a * fusc((n - 1) / 2) + b * fusc(((n - 1) / 2) + 1) && n == 1}
            {fusc(N) == a * fusc((n - 1) / 2) + b * fusc(((n - 1) / 2) + 1) && (n - 1) / 2 == 0}
            n := (n - 1) / 2;
            {fusc(N) == a * fusc(n) + b * fusc(n + 1) && n == 0}
        }
        {fusc(N) == a * fusc(n) + b * fusc(n + 1) && n == 0}
    }
}